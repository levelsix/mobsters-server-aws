package com.lvl6.mobsters.controllers;

import java.util.HashMap;
import java.util.List;

import javax.annotation.PostConstruct;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableMap;
import com.lvl6.mobsters.noneventproto.ConfigEventProtocolProto.EventProtocolRequest;
import com.lvl6.mobsters.server.EventController;

/**
 * @author kelly
 * Used to lookup event controllers by type.
 */
@Component
public class ControllerManager {
	private static final Logger log = LoggerFactory.getLogger(ControllerManager.class);

	
	/**
	 * This list is generated by spring from the @Component on every class extending EventController
	 */
	@Autowired
	private List<EventController> eventControllerList;
	
	/**
	 * Exchange point between this class and the inner class that owns the constructed HashMap.
	 */
	private static final ImmutableMap.Builder<EventProtocolRequest,EventController> mapBuilder =
		ImmutableMap.<EventProtocolRequest,EventController>builder();

	/**
	 * Creates the map of evenType --> eventController, protected by the JVM Classloader's mutex.
	 * 
	 * Given:
	 * 1)  This class is only loaded when first referenced
	 * 2)  The JVM does all classloading single threaded and protected by an internal mutex.
	 * 3)  This class is only referenced by {@link #getEventControllerByEventType(EventProtocolRequest)}
	 * 4)  Spring guarantees that {@link #setup()} is called once before any calls to 
	 *     {@link #getEventControllerByEventType(EventProtocolRequest)} can occur.
	 * 5)  Spring _cannot_ guarantee that the threads that use the controller map are invoked 
	 * 6)  {@link #setup()} populates ecListForMapConstuct.
	 * 7)  This class's static block reads ecListForMapConstuct to populate its eventControllers Map.
	 * 
	 * Result:
	 * Without this class, 
	 */
	static class MapContainer {
		private static final ImmutableMap<EventProtocolRequest, EventController> eventControllers =
			mapBuilder.build();
	}
	
	public void setEventControllerList(List<EventController> eventControllerList) {
		this.eventControllerList = eventControllerList;
		
		// This could equivalently occur in setup(), but doing it here concedes to paranoia
		// over whether Spring uses the same thread to inject as it does to @PostConstruct.
		for( final EventController ec : eventControllerList ) {
			mapBuilder.put(ec.getEventType(), ec);
		}
	}

	/**
	 * The event controllers map contents are permanently set in stone during spring initialization.
	 * 
	 * Spring cannot guarantee that this happens before any threads that will use the hash get spawned,
	 * so an inner class is used to guard construction of the map with the JVM's classloading mutex, 
	 * avoid necessity of a synchronized data structure when de-referencing the map.
	 * 
	 * Use of an immutable map is sufficient to guarantee visibility on the contents of the map, but 
	 * not the reference to it.  The inner class, however, is able to close that gap.
	 */
	@PostConstruct
	public void setup() {
		log.info(
			"Populated {} event controllers into eventRequestType-->eventController map", 
			MapContainer.eventControllers.size());
	}
	

	/**
	 * Lookup EventController from map by type
	 */
	public EventController getEventControllerByEventType(EventProtocolRequest eventType) {
		Preconditions.checkNotNull(eventType, "EventProtocolRequest (eventType) is null");
		
		if (MapContainer.eventControllers.containsKey(eventType)) {
			EventController ec = MapContainer.eventControllers.get(eventType);
			if (ec == null) {
				log.error("no eventcontroller for eventType: " + eventType);
				throw new RuntimeException("EventController of type: " + eventType + " not found");
			}
			return ec;
		}
		throw new RuntimeException("EventController of type: " + eventType + " not found");
	}
}
