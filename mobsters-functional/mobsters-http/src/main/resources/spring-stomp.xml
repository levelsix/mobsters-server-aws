<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:websocket="http://www.springframework.org/schema/websocket"
	xmlns:int="http://www.springframework.org/schema/integration"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
		http://www.springframework.org/schema/integration
		http://www.springframework.org/schema/integration/spring-integration-4.0.xsd
		http://www.springframework.org/schema/websocket
		http://www.springframework.org/schema/websocket/spring-websocket-4.0.xsd">

	<!--websocket:handlers>
		<websocket:mapping path="/gameevents" handler="subProtoWebSocketHandler"/>
		<websocket:handshake-handler ref="mobstersHandshakeHandler"/>
		<websocket:handshake-interceptors>
			<ref bean="httpSessionHandshakeInterceptor"/>
		</websocket:handshake-interceptors>
	</websocket:handlers-->

	<websocket:message-broker application-destination-prefix="/app">
		<websocket:transport message-size="1048588" send-buffer-size="1048588" send-timeout="15000"/>

		<websocket:stomp-endpoint path="/gameevents">
			<!-- Use this to defer to authentication already done at the HTTP layer, and to INITIATE the process of
				 ensuring player is not logged in anywhere else and that we have the latest for message sequencing
				 and there are at least two nodes in the cache layer prepared to follow along the event sequence
				 by loading consistent copies of the message sequence position, object graph, and next pseudo-random
				 generator seed reflecting all changes up to the most recent commit log entry. -->
			<websocket:handshake-handler ref="mobstersHandshakeHandler"/>
		</websocket:stomp-endpoint>

		<websocket:stomp-broker-relay
			relay-host="localhost" relay-port="61613" prefix="/queue, /topic" virtual-host="devmobsters"
			client-login="lvl6client" client-passcode="abc123" system-login="lvl6server" system-passcode="abc123"
			heartbeat-receive-interval="45000" heartbeat-send-interval="45000"/>

		<websocket:client-inbound-channel>
			<!-- These are the automatic defaults for a 4-core machine, verbatim.  Drop or replace with bind variables later. -->
			<websocket:executor core-pool-size="8" max-pool-size="2147483647" queue-capacity="2147483647" keep-alive-seconds="60"/>
		</websocket:client-inbound-channel>

		<websocket:client-outbound-channel>
			<!-- These are the automatic defaults for a 4-core machine, verbatim.  Drop or replace with bind variables later. -->
			<websocket:executor core-pool-size="8" max-pool-size="2147483647" queue-capacity="2147483647" keep-alive-seconds="60"/>
		</websocket:client-outbound-channel>
	   
		<websocket:broker-channel>
			<!-- These are the automatic defaults for a 4-core machine, verbatim.  Drop or replace with bind variables later. -->
			<websocket:executor core-pool-size="8" max-pool-size="2147483647" queue-capacity="2147483647" keep-alive-seconds="60"/>
		</websocket:broker-channel>
	</websocket:message-broker>

	
	-->
	
	
	<bean id="subProtoWebSocketHandler" autowire-candidate="true" lazy-init="false"
	      class="org.springframework.web.socket.messaging.SubProtocolWebSocketHandler"></bean>
	<bean id "stompSubProtoHandler" autowire-candidate="true" lazy-init="false"
	      class="org.springframework.web.socket.messaging.StompSubProtocolHandler"></bean>

	<!-- bean id="stompWebSocketSubProtoExtension" autowire-candidate="true" lazy-init="false"
		  class="org.springframework.web.socket.messaging.StompWebSocketExtension"></bean-->

</beans>